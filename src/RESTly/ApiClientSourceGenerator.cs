// Copyright Y56380X https://github.com/Y56380X/RESTly.
// Licensed under the MIT License.

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.OpenApi.Models;
using Microsoft.OpenApi.Readers;

namespace Restly;

[Generator]
public class ApiClientSourceGenerator : IIncrementalGenerator
{
	private static readonly IDictionary<OperationType, string> HttpMethodMapping =
		new Dictionary<OperationType, string>
		{
			{ OperationType.Head  , "HttpMethod.Head"   },
			{ OperationType.Get   , "HttpMethod.Get"    },
			{ OperationType.Post  , "HttpMethod.Post"   },
			{ OperationType.Put   , "HttpMethod.Put"    },
			{ OperationType.Delete, "HttpMethod.Delete" }
		};
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// collect RESTly client attributes and possible files for OpenApi specifications
		var generationBase = context.CompilationProvider
			.Select((c, _) => c.Assembly)
			.SelectMany((s, _) => s.GetAttributes()
				.Where(a => a.AttributeClass?.Name.Equals("RestlyClientAttribute") ?? false))
			.Collect()
			.Combine(context.AdditionalTextsProvider.Where(a => a.Path.EndsWith(".json") || a.Path.EndsWith(".yml") || a.Path.EndsWith(".yaml")).Collect());
		
		context.RegisterSourceOutput(generationBase, Generator);
	}

	private static void Generator(SourceProductionContext context, (ImmutableArray<AttributeData>, ImmutableArray<AdditionalText>) generationBase)
	{
		var (attributes, additionalTexts) = (generationBase.Item1, generationBase.Item2);

		// Generate API client code based on the given definition file names of the assembly attributes
		var clientDefinitions = attributes.Select(a => 
			(a.ConstructorArguments[0].Value as string, a.ConstructorArguments[1].Value as string));
		foreach (var (clientDefinition, clientName) in clientDefinitions)
		{
			if (string.IsNullOrWhiteSpace(clientDefinition) || string.IsNullOrWhiteSpace(clientName))
				return; // todo: write analyzer message

			var definitionFile = additionalTexts.SingleOrDefault(a => a.Path.EndsWith(clientDefinition));
			if (definitionFile == null)
				return; // todo: write analyzer message

			var definitionContent = definitionFile.GetText()!.ToString();
			var openApiReader = new OpenApiStringReader(new OpenApiReaderSettings
			{
				ReferenceResolution = ReferenceResolutionSetting.ResolveLocalReferences,
				LoadExternalRefs = false
			});
			var apiSpecification = openApiReader.Read(definitionContent, out _);
			apiSpecification.Info.Title = clientName;
			var apiClientCode = GenerateApiClientCode(apiSpecification);
			context.AddSource($"{clientName}.g.cs", SourceText.From(apiClientCode, Encoding.UTF8));
		}
	}

	private static string GenerateApiClientCode(OpenApiDocument apiSpecification)
	{
		// Generate request and response models code
		var modelsCode = apiSpecification.Components.Schemas
			.Select(schema => GenerateModelCode(schema.Key, schema.Value));

		// Generate REST call methods for API client
		var callsCode = apiSpecification.Paths
			.Select(path => GenerateEndpointCode(path.Key, path.Value))
			.Where(c => !string.IsNullOrWhiteSpace(c));
		
		var clientCode =
			$$"""
			  // <auto-generated/>
			  using System.Net.Http;
			  using System.Net.Http.Json;
			  using System.Text.Json;
			  
			  #nullable enable
			  
			  namespace Restly;
			  
			  public class {{apiSpecification.Info.Title}} : IDisposable
			  {
			  {{"\t"}}private readonly HttpClient _httpClient;
			  {{"\t"}}private readonly JsonSerializerOptions _jsonOptions = new JsonSerializerOptions
			  {{"\t"}}{
			  {{"\t\t"}}PropertyNameCaseInsensitive = true
			  {{"\t"}}};
			  
			  {{"\t"}}public {{apiSpecification.Info.Title}}(HttpClient httpClient)
			  {{"\t"}}{
			  {{"\t\t"}}_httpClient = httpClient;
			  {{"\t"}}}
			  
			  {{string.Join("\n\n", callsCode)}}
			  
			  {{"\t"}}public void Dispose()
			  {{"\t"}}{
			  {{"\t\t"}}_httpClient.Dispose();
			  {{"\t"}}}
			  
			  {{string.Join("\n\n", modelsCode)}}
			  }
			  """;

		return clientCode;
	}

	private static string GenerateModelCode(string modelName, OpenApiSchema schema)
	{
		var modelProperties = schema.Properties
			.Select(PropertyCode);
		return $"{"\t"}public record {modelName.Capitalize()}({string.Join(", ", modelProperties)});";

		string PropertyCode(KeyValuePair<string, OpenApiSchema> property) =>
			$"{property.Value.ToCsType()} {property.Key.Capitalize()}";
	}

	private static string GenerateEndpointCode(string pathTemplate, OpenApiPathItem pathItem)
	{
		var callsCode = pathItem.Operations
			.Select(kvp => GenerateOperationCode(pathTemplate, kvp.Key, kvp.Value))
			.Where(c => c is not null); // filter not generated code for not supported operations
		return string.Join("\n\n", callsCode);
	}

	private static string? GenerateOperationCode(string pathTemplate, OperationType operationType, OpenApiOperation operation)
	{
		// Check for operation type support
		if (!HttpMethodMapping.ContainsKey(operationType))
			return null;

		var request = operation.RequestBody is { Content: var requestContent } && requestContent.Any()
			? requestContent.Values.FirstOrDefault()
			: null;
		var response = operation.Responses
			.SelectMany(r => r.Value.Content.Select(c => c.Value))
			.FirstOrDefault();
		
		var callsCode = GenerateCallCode(pathTemplate, operationType, operation.Parameters, request, response);
		return callsCode;
	}

	private static string GenerateCallCode(string pathTemplate, OperationType operationType, 
		IEnumerable<OpenApiParameter> parameters, 
		OpenApiMediaType? request, OpenApiMediaType? response)
	{
		var methodName = GenerateMethodName();
		var methodArguments = parameters
			.Select(GenerateMethodArgumentCode)
			.ToList();
		var responseType = response is { Schema: not null}
			? $"Response<{response.Schema.ToCsType()}>"
			: "Response";
		var httpMethod = HttpMethodMapping[operationType];

		var callCodeBuilder = new StringBuilder();
		callCodeBuilder.AppendLine($"""using var request = new HttpRequestMessage({httpMethod}, $"{pathTemplate}");""");
		if (request is { Schema: not null })
		{
			methodArguments.Insert(0, $"{request.Schema.ToCsType()} body");
			callCodeBuilder.AppendLine($"{"\t\t"}request.Content = JsonContent.Create(body);");
		}
		callCodeBuilder.AppendLine($"{"\t\t"}using var response = await _httpClient.SendAsync(request);");
		if (response is { Schema: not null })
		{
			callCodeBuilder.AppendLine($"{"\t\t"}{response.Schema.ToCsType(forceNullable: true)} model;");
			callCodeBuilder.AppendLine($"{"\t\t"}if (response.IsSuccessStatusCode)");
			callCodeBuilder.AppendLine($"{"\t\t\t"}model = JsonSerializer.Deserialize<{response.Schema.ToCsType()}>(await response.Content.ReadAsStreamAsync(), _jsonOptions);");
			callCodeBuilder.AppendLine($"{"\t\t"}else");
			callCodeBuilder.AppendLine($"{"\t\t\t"}model = default;");
		}
		
		var responseArguments = new List<string>
		{
			"response.IsSuccessStatusCode",
			"response.StatusCode"
		};
		if (response != null) responseArguments.Add("model");
		
		var callCode = 
			$$"""
			  {{"\t"}}public async Task<{{responseType}}> {{methodName}}({{string.Join(", ", methodArguments)}})
			  {{"\t"}}{
			  {{"\t\t"}}{{callCodeBuilder}}
			  {{"\t\t"}}return new {{responseType}}({{string.Join(", ", responseArguments)}});
			  {{"\t"}}}
			  """;
		
		return callCode;
		
		string GenerateMethodName()
		{
			var methodFragments = pathTemplate
				.Split([' ', '/', '\\', '-', '_', '.', ':', '{', '}', '(', ')', '[', ']'], StringSplitOptions.RemoveEmptyEntries)
				.Select(f => f.Capitalize());
			return $"{operationType}{string.Concat(methodFragments)}Async"; // todo: generate better methods names (take response and parameters into account)
		}

		string GenerateMethodArgumentCode(OpenApiParameter parameter) => 
			$"{parameter.Schema.ToCsType()} {parameter.Name}";
	}
}